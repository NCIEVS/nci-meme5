/*
 * Copyright 2020 Wci Informatics - All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains the property of Wci Informatics
 * The intellectual and technical concepts contained herein are proprietary to
 * Wci Informatics and may be covered by U.S. and Foreign Patents, patents in process,
 * and are protected by trade secret or copyright law.  Dissemination of this information
 * or reproduction of this material is strictly forbidden.
 */
package com.wci.umls.server.jpa.algo.autofix;

import static org.junit.Assert.fail;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.UUID;

import javax.persistence.Query;

import com.wci.umls.server.AlgorithmParameter;
import com.wci.umls.server.ValidationResult;
import com.wci.umls.server.helpers.Branch;
import com.wci.umls.server.helpers.ConfigUtility;
import com.wci.umls.server.jpa.ValidationResultJpa;
import com.wci.umls.server.jpa.algo.AbstractInsertMaintReleaseAlgorithm;
import com.wci.umls.server.model.content.Attribute;
import com.wci.umls.server.model.content.Descriptor;

/**
 * Implementation of an algorithm to automatically fix an issue identified by a
 * Mid Validation check.
 */
public class FixDetachedDescriptorAttributesAlgorithm extends AbstractInsertMaintReleaseAlgorithm {

  /**
   * Instantiates an empty {@link FixDetachedDescriptorAttributesAlgorithm}.
   * @throws Exception if anything goes wrong
   */
  public FixDetachedDescriptorAttributesAlgorithm() throws Exception {
    super();
    setActivityId(UUID.randomUUID().toString());
    setWorkId("FIXDETACHEDDESCRIPTORATTRIBUTES");
    setLastModifiedBy("admin");
  }

  /**
   * Check preconditions.
   *
   * @return the validation result
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public ValidationResult checkPreconditions() throws Exception {

    ValidationResult validationResult = new ValidationResultJpa();

    if (getProject() == null) {
      throw new Exception("Autofix algorithms requires a project to be set");
    }

    final String srcFullPath = ConfigUtility.getConfigProperties().getProperty("source.data.dir")
        + File.separator + getProcess().getInputPath();

    setSrcDirFile(new File(srcFullPath));

    return validationResult;
  }

  /**
   * Compute.
   *
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public void compute() throws Exception {
    logInfo("Starting " + getName());

    // No Molecular actions will be generated by this algorithm
    setMolecularActionFlag(false);

    commitClearBegin();

    logInfo(" Fix Detached Descriptor Attributes");

    List<Long> attributeIds = new ArrayList<>();
    // Map is attributeId to Descriptor information: "terminologyId|terminology"
    Map<Long, String> attributeToDescriptorMap = new HashMap<>();
    Map<String, String> currentTerminologyVersions = new HashMap<>();

    try {
      // Identify all attributes that are detached from their descriptor
      Query query = getEntityManager().createNativeQuery(
          "SELECT attributeId, descriptorTerminologyId, descriptorTerminology, da.descriptors_id FROM "
              + "  (select a.id as attributeId, ai.componentId as descriptorTerminologyId, "
              + "  ai.componentTerminology as descriptorTerminology from attributes a, "
              + "  attributejpa_alternateterminologyids aat, attribute_identity ai "
              + "  WHERE a.publishable and aat.AttributeJpa_id=a.id and "
              + "  substring(aat.alternateTerminologyIds, 3) = ai.id and ai.componentType='DESCRIPTOR') "
              + "  attributeInfo "
              + "LEFT JOIN descriptors_attributes da on attributeInfo.attributeId=da.attributes_id "
              + "HAVING da.descriptors_id is null");

      List<Object[]> list = query.getResultList();

      for (final Object[] entry : list) {
        final Long attributeId = Long.valueOf(entry[0].toString());
        attributeIds.add(attributeId);
        final String descriptorTerminologyId = entry[1].toString();
        final String descriptorTerminology = entry[2].toString();

        attributeToDescriptorMap.put(attributeId,
            descriptorTerminologyId + "|" + descriptorTerminology);
      }

      logInfo("[FixDetachedDescriptorAttributes] " + attributeIds.size()
          + " attributes that need to be reattached to descriptors");

      setSteps(attributeIds.size());
      for (Long attributeId : attributeIds) {
        final Attribute attribute = getAttribute(attributeId);

        final String[] descriptorInfo = attributeToDescriptorMap.get(attributeId).split("\\|");
        final String descriptorTerminologyId = descriptorInfo[0];
        final String descriptorTerminology = descriptorInfo[1];
        String descriptorVersion = null;

        // Get the terminology's current version
        if (currentTerminologyVersions.containsKey(descriptorTerminology)) {
          descriptorVersion = currentTerminologyVersions.get(descriptorTerminology);
        } else {
          logInfo("Getting latest version for terminology=" + descriptorTerminology);
          descriptorVersion = getCurrentTerminology(descriptorTerminology).getVersion();
          currentTerminologyVersions.put(descriptorTerminology, descriptorVersion);
        }

        final Descriptor descriptor = getDescriptor(descriptorTerminologyId, descriptorTerminology,
            descriptorVersion, Branch.ROOT);

        if (descriptor == null) {
          logInfo("No descriptor found terminology=" + descriptorTerminology + ", terminologyId="
              + descriptorTerminologyId);
          updateProgress();
          continue;
        }

        descriptor.getAttributes().add(attribute);
        updateDescriptor(descriptor);
        updateProgress();
      }

      logInfo("  project = " + getProject().getId());
      logInfo("  workId = " + getWorkId());
      logInfo("  activityId = " + getActivityId());
      logInfo("  user  = " + getLastModifiedBy());
      logInfo("Finished " + getName());

      commitClearBegin();

    } catch (Exception e) {
      e.printStackTrace();

      fail("Unexpected exception thrown - please review stack trace.");
    } finally {
      // N/A
    }

    logInfo("Finished " + getName());

  }

  /* see superclass */
  @Override
  public void reset() throws Exception {
    logInfo("Starting RESET " + getName());
    // n/a - No reset
    logInfo("Finished RESET " + getName());
  }

  /* see superclass */
  @Override
  public void checkProperties(Properties p) throws Exception {
    // n/a
  }

  /* see superclass */
  @Override
  public void setProperties(Properties p) throws Exception {
    // n/a
  }

  /**
   * Returns the parameters.
   *
   * @return the parameters
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public List<AlgorithmParameter> getParameters() throws Exception {
    final List<AlgorithmParameter> params = super.getParameters();
    return params;
  }

  /* see superclass */
  @Override
  public String getDescription() {
    return "Fix Detached Descriptor Attributes.";
  }

}