/*
 *    Copyright 2015 West Coast Informatics, LLC
 */
package com.wci.umls.server.jpa.algo;

import java.util.HashSet;
import java.util.List;
import java.util.Properties;
import java.util.Set;
import java.util.UUID;

import com.wci.umls.server.AlgorithmParameter;
import com.wci.umls.server.ValidationResult;
import com.wci.umls.server.helpers.QueryType;
import com.wci.umls.server.jpa.AlgorithmParameterJpa;
import com.wci.umls.server.jpa.ValidationResultJpa;
import com.wci.umls.server.jpa.content.AtomJpa;
import com.wci.umls.server.model.content.Atom;

/**
 * Test database communication speeds.
 */
public class SpeedTestAlgorithm extends AbstractInsertMaintReleaseAlgorithm {

  /**
   * The number of times the algorithm will print to the log before finishing.
   */
  private int num;

  /**
   * Instantiates an empty {@link SpeedTestAlgorithm}.
   *
   * @throws Exception the exception
   */
  public SpeedTestAlgorithm() throws Exception {
    super();
    setActivityId(UUID.randomUUID().toString());
    setWorkId("ATOMLOADER");
    setLastModifiedBy("admin");
  }

  /* see superclass */
  @Override
  public ValidationResult checkPreconditions() throws Exception {

    ValidationResult validationResult = new ValidationResultJpa();

    if (getProject() == null) {
      throw new Exception("Speed Test requires a project to be set");
    }

    return validationResult;
  }

  /* see superclass */
  @Override
  public void compute() throws Exception {
    logInfo("Starting " + getName());

    logInfo("Processing " + String.valueOf(num) + " atoms.");

    // No molecular actions will be generated by this algorithm
    setMolecularActionFlag(false);

    /**
     * The atom cache.
     */
    Set<Long> atomIdCache = new HashSet<>();
    Set<Atom> atomCache = new HashSet<>();

    // Search for specified number of atoms from the database, one at a time
    logInfo("  Starting database read loop.");

    for (int i = 1; i < num; i++) {
      List<Long> atomIdList = executeSingleComponentIdQuery(
          "select a.id from atoms a where id=" + String.valueOf(i),
          QueryType.SQL, getDefaultQueryParams(getProject()), AtomJpa.class,
          false);
      atomIdCache.add(atomIdList.get(0));
    }
    logInfo("  Finished database read loop.");

    // Get all atoms using the ID, one at a time
    logInfo("  Starting atom load loop.");
    for (Long atomId : atomIdCache) {
      atomCache.add(getAtom(atomId));
    }
    logInfo("  Finished atom load loop.");

  }

  /* see superclass */
  @Override
  public void reset() throws Exception {
    logInfo("Starting RESET " + getName());
    // n/a - No reset
    logInfo("Finished RESET " + getName());
  }

  /* see superclass */
  @Override
  public void checkProperties(Properties p) throws Exception {
    // n/a
  }

  /* see superclass */
  @Override
  public void setProperties(Properties p) throws Exception {

    if (p.getProperty("num") != null) {
      num = Integer.parseInt(p.getProperty("num"));
    }

  }

  /* see superclass */
  @Override
  public List<AlgorithmParameter> getParameters() throws Exception {
    final List<AlgorithmParameter> params = super.getParameters();
    AlgorithmParameter param = new AlgorithmParameterJpa("Number of Iterations",
        "num", "Number of times the algorithm will run", "e.g. 1000", 1000,
        AlgorithmParameter.Type.INTEGER, "");
    params.add(param);
    return params;
  }

  /* see superclass */
  @Override
  public String getDescription() {
    return "Loads and processes a classes_atoms.src file.";
  }
}