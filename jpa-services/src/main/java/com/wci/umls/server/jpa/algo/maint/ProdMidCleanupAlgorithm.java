/*
 *    Copyright 2015 West Coast Informatics, LLC
 */
package com.wci.umls.server.jpa.algo.maint;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Properties;
import java.util.Set;
import java.util.UUID;

import javax.persistence.Query;

import com.wci.umls.server.AlgorithmParameter;
import com.wci.umls.server.ValidationResult;
import com.wci.umls.server.jpa.ValidationResultJpa;
import com.wci.umls.server.jpa.algo.AbstractInsertMaintReleaseAlgorithm;
import com.wci.umls.server.jpa.algo.RemoveTerminologyAlgorithm;
import com.wci.umls.server.jpa.services.WorkflowServiceJpa;
import com.wci.umls.server.model.meta.Terminology;
import com.wci.umls.server.model.workflow.WorkflowEpoch;
import com.wci.umls.server.services.WorkflowService;

/**
 * Implementation of an algorithm to run prod mid cleanup
 */
public class ProdMidCleanupAlgorithm
    extends AbstractInsertMaintReleaseAlgorithm {

  /**
   * Instantiates an empty {@link ProdMidCleanupAlgorithm}.
   * @throws Exception if anything goes wrong
   */
  public ProdMidCleanupAlgorithm() throws Exception {
    super();
    setActivityId(UUID.randomUUID().toString());
    setWorkId("PRODMIDCLEANUP");
    setLastModifiedBy("admin");
  }

  /**
   * Check preconditions.
   *
   * @return the validation result
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public ValidationResult checkPreconditions() throws Exception {

    ValidationResult validationResult = new ValidationResultJpa();

    if (getProject() == null) {
      throw new Exception("ProdMid Cleanup requires a project to be set");
    }

    return validationResult;
  }

  /**
   * Compute.
   *
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public void compute() throws Exception {
    logInfo("Starting " + getName());

    // No molecular actions will be generated by this algorithm
    setMolecularActionFlag(false);

    try {

      logInfo(
          "[ProdMid Cleanup] Removing contents for non-current terminologies.");
      commitClearBegin();

      // Find all non-current terminologies
      List<Terminology> nonCurrentTerminologies = new ArrayList<>();
      for (final Terminology terminology : getTerminologies().getObjects()) {
        if (!terminology.isCurrent()) {
          nonCurrentTerminologies.add(terminology);
        }
      }

      int removals = 0;
      
      WorkflowService workflowService = new WorkflowServiceJpa();
      workflowService.setLastModifiedBy("admin");
      
      WorkflowEpoch currentEpoch = workflowService.getCurrentWorkflowEpoch(getProject());

      
      Set<Long> worklistIdsToRemove = new HashSet<>();
      Set<Long> checklistIdsToRemove = new HashSet<>();

      // Get worklists
      Query query = getEntityManager().createQuery("select a.id from "
          + "WorklistJpa a"); 
          

      List<Object> list = query.getResultList();
      for (final Object entry : list) {
        final Long id = Long.valueOf(entry.toString());
        worklistIdsToRemove.add(id);
      }
      
      // Get checklists
      query = getEntityManager().createQuery("select a.id from "
          + "ChecklistJpa a"); 
          

      list = query.getResultList();
      for (final Object entry : list) {
        final Long id = Long.valueOf(entry.toString());
        checklistIdsToRemove.add(id);
      }

      logInfo("[ProdMid Cleanup] " + checklistIdsToRemove.size()
          + " checklists to be removed");
      logInfo("[ProdMid Cleanup] " + worklistIdsToRemove.size()
      + " worklists to be removed");

      setSteps(nonCurrentTerminologies.size() + checklistIdsToRemove.size() + worklistIdsToRemove.size());

      // Remove checklists
      for (Long id : checklistIdsToRemove) {
        logInfo("[ProdMid Cleanup] " + id + " checklist to be removed");
        workflowService.removeChecklist(id, true);
        updateProgress();
        removals++;
      }
      
      // Remove worklists
      for (Long id : worklistIdsToRemove) {
        logInfo("[ProdMid Cleanup] " + id + " worklist to be removed");
        workflowService.removeWorklist(id, true);
        updateProgress();
        removals++;
      }

      logInfo("[ProdMid Cleanup] " + removals
          + " lists successfully removed.");
      
      // For each non-current terminology, run removeTerminologies on it (keep
      // the terminology itself for tracking purposes).
      for (final Terminology nonCurrentTerminology : nonCurrentTerminologies) {
        final RemoveTerminologyAlgorithm algo =
            new RemoveTerminologyAlgorithm();
        try {
          logInfo("  Removing content associated with "
              + nonCurrentTerminology.getTerminology() + "/"
              + nonCurrentTerminology.getVersion());

          algo.setLastModifiedBy(getLastModifiedBy());
          algo.setTerminology(nonCurrentTerminology.getTerminology());
          algo.setVersion(nonCurrentTerminology.getVersion());
          algo.setKeepTerminology(true);
          algo.setWorkId(getWorkId());
          algo.setActivityId(getActivityId());
          algo.setProject(getProject());
          algo.compute();
          algo.close();

        } catch (Exception e) {
          logError("Unexpected problem - " + e.getMessage());
          algo.rollback();
          algo.close();
          throw e;
        }

        // Update the progress
        updateProgress();
      }

      
      commitClearBegin();
      


      // Consider truncating action tables, log entries, etc.

      logInfo("[ProdMid Cleanup] Removed content for " + getSteps()
          + " non-current terminologies.");

      logInfo("  project = " + getProject().getId());
      logInfo("  workId = " + getWorkId());
      logInfo("  activityId = " + getActivityId());
      logInfo("  user  = " + getLastModifiedBy());
      logInfo("Finished " + getName());

    } catch (

    Exception e) {
      logError("Unexpected problem - " + e.getMessage());
      throw e;
    }

  }

  /* see superclass */
  @Override
  public void reset() throws Exception {
    logInfo("Starting RESET " + getName());
    // n/a - No reset
    logInfo("Finished RESET " + getName());
  }

  /* see superclass */
  @Override
  public void checkProperties(Properties p) throws Exception {
    // n/a
  }

  /* see superclass */
  @Override
  public void setProperties(Properties p) throws Exception {
    // n/a
  }

  /**
   * Returns the parameters.
   *
   * @return the parameters
   */
  /* see superclass */
  @Override
  public List<AlgorithmParameter> getParameters() throws Exception {
    final List<AlgorithmParameter> params = super.getParameters();
    return params;
  }

  /* see superclass */
  @Override
  public String getDescription() {
    return "Removes contents for non-current terminologies";
  }

}