/*
 *    Copyright 2019 West Coast Informatics, LLC
 */
package com.wci.umls.server.jpa.algo.autofix;

import static org.junit.Assert.fail;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.UUID;

import javax.persistence.Query;

import com.wci.umls.server.AlgorithmParameter;
import com.wci.umls.server.ValidationResult;
import com.wci.umls.server.helpers.ConfigUtility;
import com.wci.umls.server.jpa.ValidationResultJpa;
import com.wci.umls.server.jpa.algo.AbstractInsertMaintReleaseAlgorithm;
import com.wci.umls.server.jpa.content.ConceptRelationshipJpa;
import com.wci.umls.server.model.content.ConceptRelationship;
import com.wci.umls.server.model.meta.AdditionalRelationshipType;
import com.wci.umls.server.model.meta.RelationshipType;
import com.wci.umls.server.services.handlers.IdentifierAssignmentHandler;

/**
 * Implementation of an algorithm to automatically fix an issue identified by a
 * Mid Validation check.
 */
public class FixNullRUIAlgorithm extends AbstractInsertMaintReleaseAlgorithm {

  /**
   * Instantiates an empty {@link FixNullRUIAlgorithm}.
   * @throws Exception if anything goes wrong
   */
  public FixNullRUIAlgorithm() throws Exception {
    super();
    setActivityId(UUID.randomUUID().toString());
    setWorkId("FIXNULLRUI");
    setLastModifiedBy("admin");
  }

  /**
   * Check preconditions.
   *
   * @return the validation result
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public ValidationResult checkPreconditions() throws Exception {

    ValidationResult validationResult = new ValidationResultJpa();

    if (getProject() == null) {
      throw new Exception("Autofix algorithms requires a project to be set");
    }

    final String srcFullPath =
        ConfigUtility.getConfigProperties().getProperty("source.data.dir")
            + File.separator + getProcess().getInputPath();

    setSrcDirFile(new File(srcFullPath));

    return validationResult;
  }

  /**
   * Compute.
   *
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public void compute() throws Exception {
    logInfo("Starting " + getName());

    // No Molecular actions will be generated by this algorithm
    setMolecularActionFlag(false);

    commitClearBegin();

    logInfo(" Fix null RUIs");

    List<Long> relsToFix = new ArrayList<>();
    Map<String, String> relTypeMap = new HashMap<>();

    IdentifierAssignmentHandler handler =
        newIdentifierAssignmentHandler(getProject().getTerminology());
    handler.setTransactionPerOperation(false);
    handler.beginTransaction();

    try {

      for (final RelationshipType rel : getRelationshipTypes(
          getProject().getTerminology(), getProject().getVersion())
              .getObjects()) {
        relTypeMap.put(rel.getAbbreviation(),
            rel.getInverse().getAbbreviation());
      }
      for (final AdditionalRelationshipType rel : getAdditionalRelationshipTypes(
          getProject().getTerminology(), getProject().getVersion())
              .getObjects()) {
        relTypeMap.put(rel.getAbbreviation(),
            rel.getInverse().getAbbreviation());
      }

      // Identify all concept relationships with null alternate terminology ids
      // (RUIs)
      // REAL QUERY
      Query query = getEntityManager().createNativeQuery(
          "select cr.id from concept_relationships cr left join conceptrelationshipjpa_alternateterminologyids crat on cr.id=crat.ConceptRelationshipJpa_id where cr.publishable and crat.alternateTerminologyIds is null and terminology != 'NCIMTH'");

      List<Object> list = query.getResultList();

      for (final Object entry : list) {
        final Long id = Long.valueOf(entry.toString());
        relsToFix.add(id);
      }

      logInfo("[FixNullRUIs] " + relsToFix.size()
          + " Concept relationships identified with null RUIs");

      setSteps(relsToFix.size());
      for (Long relId : relsToFix) {
        ConceptRelationship relationship =
            (ConceptRelationship) getRelationship(relId,
                ConceptRelationshipJpa.class);

        if (!relationship.getTerminology().equals("MTH")) {
          continue;
        }
        final String inverseRelType =
            relTypeMap.get(relationship.getRelationshipType());
        final String inverseAdditionalRelType =
            relTypeMap.get(relationship.getAdditionalRelationshipType());
        final String relationshipRui = handler.getTerminologyId(relationship,
            inverseRelType, inverseAdditionalRelType);
        relationship.getAlternateTerminologyIds().size();
        relationship.getAlternateTerminologyIds()
            .put(getProject().getTerminology(), relationshipRui);
        updateRelationship(relationship);
        updateProgress();
      }

      logInfo("  project = " + getProject().getId());
      logInfo("  workId = " + getWorkId());
      logInfo("  activityId = " + getActivityId());
      logInfo("  user  = " + getLastModifiedBy());
      logInfo("Finished " + getName());      
      
      commitClearBegin();
      handler.commit();
      handler.close();

    } catch (Exception e) {
      e.printStackTrace();
      handler.rollback();
      handler.close();
      fail("Unexpected exception thrown - please review stack trace.");
    } finally {

    }

    logInfo("Finished " + getName());

  }

  /* see superclass */
  @Override
  public void reset() throws Exception {
    logInfo("Starting RESET " + getName());
    // n/a - No reset
    logInfo("Finished RESET " + getName());
  }

  /* see superclass */
  @Override
  public void checkProperties(Properties p) throws Exception {
    // n/a
  }

  /* see superclass */
  @Override
  public void setProperties(Properties p) throws Exception {
    // n/a
  }

  /**
   * Returns the parameters.
   *
   * @return the parameters
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public List<AlgorithmParameter> getParameters() throws Exception {
    final List<AlgorithmParameter> params = super.getParameters();
    return params;
  }

  /* see superclass */
  @Override
  public String getDescription() {
    return "Perform null RUI autofix.";
  }

}