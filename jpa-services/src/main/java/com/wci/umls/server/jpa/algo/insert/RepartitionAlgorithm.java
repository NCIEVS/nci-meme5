/*
 *    Copyright 2015 West Coast Informatics, LLC
 */
package com.wci.umls.server.jpa.algo.insert;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.UUID;

import com.wci.umls.server.AlgorithmParameter;
import com.wci.umls.server.Project;
import com.wci.umls.server.ValidationResult;
import com.wci.umls.server.helpers.LocalException;
import com.wci.umls.server.jpa.AlgorithmParameterJpa;
import com.wci.umls.server.jpa.ValidationResultJpa;
import com.wci.umls.server.jpa.algo.AbstractInsertMaintReleaseAlgorithm;
import com.wci.umls.server.model.workflow.WorkflowBin;
import com.wci.umls.server.model.workflow.WorkflowBinDefinition;
import com.wci.umls.server.model.workflow.WorkflowConfig;

/**
 * Implementation of an algorithm to repartition bins.
 */
public class RepartitionAlgorithm extends AbstractInsertMaintReleaseAlgorithm {

  /** The type. */
  private String type;

  /**
   * Flag for when this is being called by a UI rest run (rather than via a
   * process).
   */
  private Boolean UIRun = false;

  /**
   * Instantiates an empty {@link RepartitionAlgorithm}.
   * @throws Exception if anything goes wrong
   */
  public RepartitionAlgorithm() throws Exception {
    super();
    setActivityId(UUID.randomUUID().toString());
    setWorkId("REPARTITION");
    setLastModifiedBy("admin");
  }

  /**
   * Check preconditions.
   *
   * @return the validation result
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public ValidationResult checkPreconditions() throws Exception {

    ValidationResult validationResult = new ValidationResultJpa();

    if (getProject() == null) {
      throw new Exception("Repartition requires a project to be set");
    }

    return validationResult;
  }

  /**
   * Compute.
   *
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public void compute() throws Exception {
    logInfo("Starting " + getName());
    logInfo("  type = " + type);

    // No molecular actions will be generated by this algorithm
    setMolecularActionFlag(false);
    

    

    // This algorithm has two steps: clearing the bins, and regenerating the
    // bins
    setSteps(2);

    setLastModifiedBy(getLastModifiedBy());

    // Load the project and workflow config
    Project project = getProject();
    // verifyProject -> n/a because we're getting bins for a project
    if (!project.isEditingEnabled() && UIRun) {
      throw new LocalException(
          "Editing is disabled on project: " + getProject().getName());
    }

    // Start by clearing the bins
    // remove bins and all of the tracking records in the bins
    logInfo("  Clearing Current " + type + " Bins");
    commitClearBegin();

    final List<WorkflowBin> results = getWorkflowBins(project, type);
    for (final WorkflowBin workflowBin : results) {
      removeWorkflowBin(workflowBin.getId(), true);
    }

    commit();
    beginTransaction();

    // Update the progress
    updateProgress();

    logInfo("  Clearing Current " + type + " Bins Completed");
    logInfo("  Regenerating " + type + " Bins");
    commitClearBegin();

    // reread after the commit
    project = getProject(project.getId());

    final WorkflowConfig workflowConfig = getWorkflowConfig(project, type);

    // start progress monitoring for all of the bins
    for (final WorkflowBinDefinition definition : workflowConfig
        .getWorkflowBinDefinitions()) {
      startProcess(project.getId(), definition.getName());  
    }
    
    // concepts seen set
    final Set<Long> conceptsSeen = new HashSet<>();
    final Map<Long, String> conceptIdWorklistNameMap =
        getConceptIdWorklistNameMap(getProject());

    // Look up the bin definitions
    int rank = 0;
    for (final WorkflowBinDefinition definition : workflowConfig
        .getWorkflowBinDefinitions()) {
      checkCancel();

      regenerateBinHelper(project, definition, ++rank, conceptsSeen,
          conceptIdWorklistNameMap);

      // finish progress monitoring for each bin, as it finishes
      finishProcess(project.getId(), definition.getName());  
    }
    commitClearBegin();

    // Update the progress
    updateProgress();

    logInfo("  Regenerating " + type + " Bins Completed");

    logInfo("Finished " + getName());

  }

  /**
   * Reset.
   *
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public void reset() throws Exception {
    logInfo("Starting RESET " + getName());
    // n/a - No reset
    logInfo("Finished RESET " + getName());
  }

  /* see superclass */
  @Override
  public void checkProperties(Properties p) throws Exception {
    // n/a
  }

  /* see superclass */
  @Override
  public void setProperties(Properties p) throws Exception {
    if (p.getProperty("type") != null) {
      type = String.valueOf(p.getProperty("type"));
    }
    if (p.getProperty("UIRun") != null) {
      UIRun = Boolean.parseBoolean(p.getProperty("UIRun"));
    }
  }

  /**
   * Returns the parameters.
   *
   * @return the parameters
   */
  /* see superclass */
  @Override
  public List<AlgorithmParameter> getParameters() throws Exception {
    final List<AlgorithmParameter> params = super.getParameters();

    // Load all workflow configs, get all types, populate pick-list for workflow
    // bin type parameter
    // Set default value to first mutually exclusive config found.
    List<String> possibleValues = new ArrayList<>();
    String defaultValue = "";
    final List<WorkflowConfig> configs = getWorkflowConfigs(getProject());
    for (WorkflowConfig config : configs) {
      possibleValues.add(config.getType());
      if (defaultValue.equals("")) {
        if (config.isMutuallyExclusive()) {
          defaultValue = config.getType();
        }
      }
    }

    AlgorithmParameter param = new AlgorithmParameterJpa("Workflow Bin Type",
        "type", "The type of workflow bin to repartition",
        "e.g. MUTUALLY_EXCLUSIVE", 40, AlgorithmParameter.Type.ENUM,
        defaultValue);
    param.setPossibleValues(possibleValues);
    params.add(param);

    // Don't need a parameter for UIrun - defaults to False, and only gets set
    // to true when being called via WorkflowServiceRestImpl.regenerateBins

    return params;
  }

  @Override
  public String getDescription() {
    return "Regenerates workflow bins.";
  }
}