/*
 *    Copyright 2019 West Coast Informatics, LLC
 */
package com.wci.umls.server.jpa.algo.autofix;

import static org.junit.Assert.fail;

import java.io.File;
import java.util.HashSet;
import java.util.List;
import java.util.Properties;
import java.util.Set;
import java.util.UUID;

import javax.persistence.Query;

import com.wci.umls.server.AlgorithmParameter;
import com.wci.umls.server.ValidationResult;
import com.wci.umls.server.helpers.ConfigUtility;
import com.wci.umls.server.jpa.ValidationResultJpa;
import com.wci.umls.server.jpa.algo.AbstractInsertMaintReleaseAlgorithm;
import com.wci.umls.server.model.content.Atom;
import com.wci.umls.server.model.content.AtomRelationship;
import com.wci.umls.server.model.workflow.WorkflowStatus;

/**
 * Implementation of an algorithm to automatically fix an issue identified by a
 * Mid Validation check.
 */
public class FixCRelMatchingDemotionAlgorithm
    extends AbstractInsertMaintReleaseAlgorithm {

  /**
   * Instantiates an empty {@link FixCRelMatchingDemotionAlgorithm}.
   * @throws Exception if anything goes wrong
   */
  public FixCRelMatchingDemotionAlgorithm() throws Exception {
    super();
    setActivityId(UUID.randomUUID().toString());
    setWorkId("FIXCRELMATCHINGDEMOTION");
    setLastModifiedBy("admin");
  }

  /**
   * Check preconditions.
   *
   * @return the validation result
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public ValidationResult checkPreconditions() throws Exception {

    ValidationResult validationResult = new ValidationResultJpa();

    if (getProject() == null) {
      throw new Exception("Autofix algorithms requires a project to be set");
    }

    final String srcFullPath =
        ConfigUtility.getConfigProperties().getProperty("source.data.dir")
            + File.separator + getProcess().getInputPath();

    setSrcDirFile(new File(srcFullPath));

    return validationResult;
  }

  /**
   * Compute.
   *
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public void compute() throws Exception {
    logInfo("Starting " + getName());

    // No Molecular actions will be generated by this algorithm
    setMolecularActionFlag(false);

    commitClearBegin();

    logInfo(" Fix C Rels Matching Demotions");

    try {

      // Identify all concepts/atoms that have both a c-level relationship and
      // demotion
      Query query = getEntityManager().createNativeQuery(
          "select ar.from_id atomId1, ar.to_id atomId2 from atom_relationships ar, concept_relationships cr,      concepts_atoms ca1, concepts_atoms ca2 where ar.terminology = 'NCIMTH' and cr.terminology = 'NCIMTH'   and ar.from_id = ca1.atoms_id and ar.to_id = ca2.atoms_id   and cr.from_id = ca1.concepts_id and cr.to_id = ca2.concepts_id   and ar.workflowStatus = 'DEMOTION'   and cr.workflowStatus in ('READY_FOR_PUBLICATION','PUBLISHED')");

      List<Object[]> results = query.getResultList();

      logInfo("[FixCRelsMatchingDemotions] " + results.size()
          + " C level relationships matching demotions identified");

      setSteps(results.size());

      // Track which atom pairs have already been processed
      final Set<String> processedAtomPairs = new HashSet<>();

      for (final Object[] entry : results) {
        final Long fromAtomId = Long.parseLong(entry[0].toString());
        final Long toAtomId = Long.parseLong(entry[1].toString());

        if (processedAtomPairs.contains(fromAtomId + "|" + toAtomId)) {
          updateProgress();
          continue;
        } else {
          processedAtomPairs.add(fromAtomId + "|" + toAtomId);
          processedAtomPairs.add(toAtomId + "|" + fromAtomId);
        }

        final Atom fromAtom = getAtom(fromAtomId);
        final Atom toAtom = getAtom(toAtomId);

        AtomRelationship fromDemotionRelationship = null;
        AtomRelationship toDemotionRelationship = null;

        for (AtomRelationship atomRelationship : fromAtom.getRelationships()) {
          if (atomRelationship.getTo().getId().equals(toAtomId)) {
            fromDemotionRelationship = atomRelationship;
            break;
          }
        }
        for (AtomRelationship atomRelationship : toAtom.getRelationships()) {
          if (atomRelationship.getTo().getId().equals(fromAtomId)) {
            toDemotionRelationship = atomRelationship;
            break;
          }
        }

        if (fromDemotionRelationship == null
            || toDemotionRelationship == null) {
          logWarn("Unexpected null demotion relationship between atoms "
              + fromAtomId + " and " + toAtomId);
          updateProgress();
          continue;
        }

        if (fromAtom.getWorkflowStatus().equals(WorkflowStatus.DEMOTION)) {
          fromAtom.setWorkflowStatus(WorkflowStatus.NEEDS_REVIEW);
        }
        fromAtom.getRelationships().remove(fromDemotionRelationship);
        updateAtom(fromAtom);
        removeRelationship(fromDemotionRelationship.getId(),
            fromDemotionRelationship.getClass());

        if (toAtom.getWorkflowStatus().equals(WorkflowStatus.DEMOTION)) {
          toAtom.setWorkflowStatus(WorkflowStatus.NEEDS_REVIEW);
        }
        toAtom.getRelationships().remove(toDemotionRelationship);
        updateAtom(toAtom);
        removeRelationship(toDemotionRelationship.getId(),
            toDemotionRelationship.getClass());

        updateProgress();
      }

      logInfo("  project = " + getProject().getId());
      logInfo("  workId = " + getWorkId());
      logInfo("  activityId = " + getActivityId());
      logInfo("  user  = " + getLastModifiedBy());
      logInfo("Finished " + getName());

      commitClearBegin();

    } catch (Exception e) {
      e.printStackTrace();
      fail("Unexpected exception thrown - please review stack trace.");
    } finally {

    }

    logInfo("Finished " + getName());

  }

  /* see superclass */
  @Override
  public void reset() throws Exception {
    logInfo("Starting RESET " + getName());
    // n/a - No reset
    logInfo("Finished RESET " + getName());
  }

  /* see superclass */
  @Override
  public void checkProperties(Properties p) throws Exception {
    // n/a
  }

  /* see superclass */
  @Override
  public void setProperties(Properties p) throws Exception {
    // n/a
  }

  /**
   * Returns the parameters.
   *
   * @return the parameters
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public List<AlgorithmParameter> getParameters() throws Exception {
    final List<AlgorithmParameter> params = super.getParameters();
    return params;
  }

  /* see superclass */
  @Override
  public String getDescription() {
    return "Perform C Rel Matching Demotion autofix.";
  }

}