/*
 *    Copyright 2015 West Coast Informatics, LLC
 */
package com.wci.umls.server.jpa.algo.insert;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;
import java.util.UUID;

import javax.persistence.Query;

import com.wci.umls.server.AlgorithmParameter;
import com.wci.umls.server.ValidationResult;
import com.wci.umls.server.helpers.ConfigUtility;
import com.wci.umls.server.helpers.FieldedStringTokenizer;
import com.wci.umls.server.jpa.AlgorithmParameterJpa;
import com.wci.umls.server.jpa.ValidationResultJpa;
import com.wci.umls.server.jpa.algo.AbstractInsertMaintReleaseAlgorithm;
import com.wci.umls.server.model.content.Concept;

/**
 * In effort to reduce deleted_cuis, create bequeathals to the live parent 
 * grandparent or ancestor.  Replaces the deprecated CreateAncestorBequeathalAlgorithm
 * which is slow and only bequeaths up to grandparents.
 */
public class CreateEfficientAncestorBequeathalAlgorithm extends AbstractInsertMaintReleaseAlgorithm {

  // currently, algorithm with address one terminology at a time - indicate here
  private String terminologyParam = null;
  
  /**
   * Instantiates an empty {@link CreateEfficientAncestorBequeathalAlgorithm}.
   * @throws Exception if anything goes wrong
   */
  public CreateEfficientAncestorBequeathalAlgorithm() throws Exception {
    super();
    setActivityId(UUID.randomUUID().toString());
    setWorkId("CREATEEFFICIENTANCESTORBEQUEATH");
    setLastModifiedBy("admin");
  }

  /* see superclass */
  @Override
  public ValidationResult checkPreconditions() throws Exception {

    ValidationResult validationResult = new ValidationResultJpa();

    if (getProject() == null) {
      throw new Exception("Create ancestor bequeath requires a project to be set");
    }

    // Check the input directories

    final String srcFullPath =
        ConfigUtility.getConfigProperties().getProperty("source.data.dir")
            + File.separator + getProcess().getInputPath();

    setSrcDirFile(new File(srcFullPath));
    /**if (!getSrcDirFile().exists()) {
      throw new Exception("Specified input directory does not exist");
    } */

    return validationResult;
  }

  /* see superclass */
  @Override
  public void compute() throws Exception {
    logInfo("Starting " + getName());

    int addedCount = 0;
    
    // No molecular actions will be generated by this algorithm
    setMolecularActionFlag(false);

    try {

      Set<Concept> deletedCuis = new HashSet<>();
      File srcDir = getSrcDirFile();
      File maintDir = new File(srcDir, "maint");
      if (! maintDir.exists()){
        maintDir.mkdir();
      }
      logInfo("maint dir:" + maintDir);
      BufferedWriter out = new BufferedWriter(new FileWriter(new File(maintDir, "bequeathal.ancestor.relationships.src." + terminologyParam)));
      
      Query query = getEntityManager().createNativeQuery(
          "SELECT   DISTINCT c.id conceptId FROM   concepts c,   "
          + "concepts_atoms ca,   atoms a WHERE   c.terminology = 'NCIMTH'   "
          + "AND c.id != c.terminologyId   AND c.id = ca.concepts_id   AND "
          + "ca.atoms_id = a.id   "
          + "AND a.publishable = FALSE   AND NOT c.id IN ("
          +   "SELECT       DISTINCT c.id conceptId     " 
          +   " FROM       concepts c,       concepts_atoms ca,       atoms a     "
          +   " WHERE       c.terminology = 'NCIMTH'       AND c.id = ca.concepts_id   "
          +   " AND ca.atoms_id = a.id       AND a.publishable = TRUE   )   " 
          +   " AND NOT c.id IN (     "
          +   "   SELECT       DISTINCT c.id conceptId     "
          +   "    FROM       concepts c,       concept_relationships cr     "
          +   "    WHERE       c.terminology = 'NCIMTH'       AND c.id = cr.from_id       "
          +   "    AND cr.relationshipType like 'B%'   )   AND NOT c.id IN (     "
          +   "      SELECT       c.id conceptId     " 
          +   "        FROM       concepts c,       concepts_atoms ca     "
          +   "        WHERE       c.terminology = 'NCIMTH'       "
          +   "        AND c.id = ca.concepts_id       AND ca.concepts_id IN (         "
          +   "      SELECT           ca.concepts_id         FROM           concepts_atoms ca,           atoms a         " 
          +   "        WHERE           ca.atoms_id = a.id           "
          +   "        AND a.terminology IN (:terminology, 'NCIMTH')           " 
          +   "        AND a.termType = 'PN'       )     GROUP BY       ca.concepts_id     "
          +   "        HAVING       COUNT(DISTINCT ca.atoms_id) = 1   )"
          +   " AND NOT c.id IN (   "
          +   "   SELECT  " 
          +   "     ca.concepts_id conceptId  "
          +   "   FROM  "
          +   "     mrcui mr,  "
          +  "      atomjpa_conceptterminologyids ac,  "
          +  "      concepts_atoms ca,  "
          +  "      concepts cpt  "
          + "     WHERE  "
          +  "      mr.cui1 = ac.conceptTerminologyIds  "
          +  "      AND ca.atoms_id = ac.AtomJpa_id  "
          +  "      AND cpt.id = ca.concepts_id  "
          +  "      AND cpt.terminology = 'NCIMTH'  "
          +  "      AND ac.conceptTerminologyIds_KEY = 'NCIMTH'  "
          +  "      AND mr.rel = 'DEL'  )"
        
          
          );
      
      query.setParameter("terminology",
              getProcess().getTerminology());
      List<Object> list = query.getResultList();
      setSteps(list.size());
      //List<Object> list = new ArrayList<>();
      //list.add("25250919");
      //list.add("30310940");
      //list.add("30311007");
      //list.add("30311025");
      //setSteps(4);
      
      int index = 1;
      for (final Object entry : list) {
        final Long id = Long.valueOf(entry.toString());
        Concept c = getConcept(id);
        deletedCuis.add(c);
        c.getAtoms().size();
        c.getRelationships().size();
      } 
      
      // compute atom rels used in deletedCuis, for given terminology e.g. NCBI
      List <RelObject> rels = new ArrayList<>();
      Map<String,  List<RelObject>> relMap = new HashMap<>();
      Query relQuery = getEntityManager().createNativeQuery(
          "select c1.terminologyId cui1, c2.terminologyId cui2, c2.publishable " +
          "FROM atom_relationships r, concepts_atoms ca1, concepts_atoms ca2, concepts c1, concepts c2 " +
           "WHERE   r.terminology = :terminology  AND r.to_id = ca1.atoms_id  AND r.from_id = ca2.atoms_id " +
          " AND c1.id = ca1.concepts_id  AND c2.id = ca2.concepts_id " + 
          " AND c1.terminology='NCIMTH' AND c2.terminology='NCIMTH' AND r.relationshipType = 'PAR'"); 
      relQuery.setParameter("terminology",terminologyParam); 
      //Query relQuery = getEntityManager().createNativeQuery(
      //    "select cui1, cui2, publishable from relMap");
      List<Object[]> results = relQuery.getResultList();
      for (final Object[] entry : results) {
        final String fromCui = entry[0].toString();
        final String toCui = entry[1].toString();
        final Boolean toPublishable = Boolean.parseBoolean(entry[2].toString());
        RelObject rel = new RelObject(fromCui, toCui, toPublishable);
        rels.add(rel);
      }
      logInfo("rels.size: " + rels.size());
      
      // put par/chd rels in relMap
      for (RelObject rel : rels) {
        if (relMap.containsKey(rel.getCui1())) {
          List<RelObject> llist = relMap.get(rel.getCui1());
          llist.add(rel);
          relMap.put(rel.getCui1(), llist);
        } else {
          List<RelObject> llist = new ArrayList<>();
          llist.add(rel);
          relMap.put(rel.getCui1(), llist);
        }
      }
      logInfo("relMap.size: " + relMap.size());
      Entry<String, List<RelObject>> entry = relMap.entrySet().iterator().next();
      
      // determine potential bequeathals for each deleted cui
      for (Concept cpt : deletedCuis) {

        index++;
        List<String> pathResults = computeTransitiveClosure(cpt.getTerminologyId(),relMap,"");
        
        if (pathResults != null) {
          // max of 5 bequeathals for each cui
          for (int i=0; i<pathResults.size() && i<5; i++) {
            String result = pathResults.get(i);
            // this returns things like .CUI1.CUI2.CUI3.CUI4 => bequeathal rel is
            // CUI1=>CUI4
            String[] tokens = FieldedStringTokenizer.split(result, ".");
            StringBuffer sb = new StringBuffer();
            sb.append("").append("|");
            sb.append("C").append("|");
            sb.append(tokens[1]).append("|");
            sb.append("BBT").append("|").append("|");
            sb.append(tokens[tokens.length - 1]).append("|");
            sb.append("NCIMTH|NCIMTH|R|n|N|N|SOURCE_CUI|NCIMTH|SOURCE_CUI|NCIMTH|||").append("\n");

            // write bequeathal rel entries 
            out.write(sb.toString());
            
            updateProgress();
            if (index % 100 == 0) {
              out.flush();
            }
          }
        }
      }
 
      out.close();

      commitClearBegin();

      logInfo("  added count = " + addedCount);

      logInfo("Finished " + getName());

    } catch (

    Exception e) {
      logError("Unexpected problem - " + e.getMessage());
      throw e;
    }

  }

  public List<String> computeTransitiveClosure(String cui, Map<String, List<RelObject>> relMap, String ancestorPath) {
    // assumption: cui is not publishable  

    // check for cycles
    if (ancestorPath.contains(cui+".")) {
      return new ArrayList<>(0);
    }

    List<String> results = new ArrayList<>();
    List<RelObject> relObjs = relMap.get(cui);
    if (relObjs == null) {
      return null;
    }
    for (RelObject rel : relMap.get(cui)) {
      String cui2 = rel.getCui2();
      boolean publishable = Boolean.valueOf(rel.isCui2Publishable());
      if (publishable) {
         results.add ((ancestorPath.equals("") ? "" :  (ancestorPath + ".")) + cui + "." + cui2);
      }
      else {
         results.addAll(computeTransitiveClosure(cui2, relMap, ancestorPath + "." + cui));
      }
    }

    return results;
  }
  

  
  /* see superclass */
  @Override
  public void reset() throws Exception {
    logInfo("Starting RESET " + getName());
    // n/a - No reset
    logInfo("Finished RESET " + getName());
  }

  /* see superclass */
  @Override
  public void checkProperties(Properties p) throws Exception {
    checkRequiredProperties(new String[] {
        "terminology"
    }, p);
  }

  /* see superclass */
  @Override
  public void setProperties(Properties p) throws Exception {
    terminologyParam = String.valueOf(p.getProperty("terminology"));
  }

  /* see superclass */
  @Override
  public List<AlgorithmParameter> getParameters() throws Exception {
    final List<AlgorithmParameter> params = super.getParameters();
    AlgorithmParameter param = new AlgorithmParameterJpa("Terminology", "terminology",
        "Deleted cuis with this terminology will be addressed in this run.",
        "e.g. NCBI", 200, AlgorithmParameter.Type.STRING, "");
    params.add(param);

    return params;
  }

  @Override
  public String getDescription() {
    return "Bequeaths deleted cuis to their closest published ancestor";
  }

  private class RelObject {
    private String cui1;
    private String cui2;
    private boolean cui2Publishable;
    
    public RelObject(String cui1, String cui2, Boolean publishable) {
      setCui1(cui1);
      setCui2(cui2);
      setCui2Publishable(publishable);
    }
    
    public String getCui1() {
      return cui1;
    }
    public void setCui1(String cui1) {
      this.cui1 = cui1;
    }
    public String getCui2() {
      return cui2;
    }
    public void setCui2(String cui2) {
      this.cui2 = cui2;
    }
    public boolean isCui2Publishable() {
      return cui2Publishable;
    }
    public void setCui2Publishable(boolean cui2Publishable) {
      this.cui2Publishable = cui2Publishable;
    }
    
    
  }
}